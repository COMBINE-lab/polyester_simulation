rsem <- read.delim("out.isoforms.results")

library(ensembldb)
txdb.filename <- "reference.sqlite"
if (!file.exists(txdb.filename)) ensDbFromGtf("reference.gtf")
txdb <- EnsDb(txdb.filename)
txdf <- transcripts(txdb, return.type="DataFrame")
rsem$gene_id <- txdf$gene_id[match(rsem$transcript_id, txdf$tx_id)]
rsem <- rsem[order(rsem$gene_id),]

tpm <- rsem$TPM
names(tpm) <- rsem$transcript_id
gsplit <- split(seq_len(nrow(rsem)), rsem$gene_id)
tpm.per.gene <- sapply(gsplit, function(idx) sum(tpm[idx]))

# now assign random vectors of expression to isoforms in genes
random.iso.percent <- function(n) {
  if (n == 1) { # one isoform
    return(1)
  } else if (n == 2) { # two isoforms
    if (sample(0:1,1)) { # flip coin
      return(sample(0:1,2)) # only 1 iso expressed
    } else {
      x <- runif(1)
      two <- c(x, 1-x) # both expressed
      return(two) 
    }
  } else { # three or more isoforms
    if (sample(0:1,1)) { # flip coin
      return(sample(c(1,rep(0,n-1)),n)) # only 1 iso expressed
    } else {
      x <- sort(runif(2))
      three <- c(x[1], diff(c(x,1))) # three iso expressed
      return(sample(c(three, rep(0, n-3)), n)) 
    }
  }
}

# some random number generation here,
# randomly assigning TPM within genes
set.seed(1)
gene.tab <- as.numeric(table(rsem$gene_id))
gene.iso <- lapply(gene.tab, random.iso.percent)
iso.tpm <- rep(tpm.per.gene, times=gene.tab) * unlist(gene.iso)
names(iso.tpm) <- rsem$transcript_id

per.nuc <- iso.tpm * rsem$length
over.lib.size <- 40e6 # we will sample down from this
sim_counts <- per.nuc / sum(per.nuc) * over.lib.size
names(sim_counts) <- rsem$transcript_id

fasta <- "reference.fa"
library(Biostrings)
txseq <- readDNAStringSet(fasta)
gc <- as.numeric(letterFrequency(txseq, "GC", as.prob=TRUE))
mean(gc)
sd(gc)

sim_counts <- sim_counts[ names(txseq) ]
stopifnot(all(names(txseq) == names(sim_counts)))
sim_counts[sim_counts < 1] <- 0

idx <- sim_counts > 0
txseq_sub <- txseq[idx]
writeXStringSet(txseq_sub, "transcripts.fa")
sim_counts <- sim_counts[idx]
stopifnot(all(names(txseq_sub) == names(sim_counts)))

# some more random number generation here,
# picking which transcripts will be DE
set.seed(1)
n <- length(sim_counts)
de.ratio <- 0.1
fold.change <- sample(c(1,0.5,2), n, replace=TRUE,
                      prob=c(1-de.ratio,de.ratio/2,de.ratio/2))
table(fold.change)
# the format for polyester
fold_changes <- matrix(c(rep(1, n),fold.change),ncol=2)
rownames(fold_changes) <- names(txseq_sub)

library(splines)
load("fitpar_all.rda")

library(digest)
# this is the md5 sum for the fitpar object
# generated by alpine 0.1.2 with the VLMM fix
fitpar.md5 <- "c79743184c061189060a522a97f4fc51"
stopifnot(digest(fitpar, algo="md5") == fitpar.md5)

samps <- read.delim("geuvadis_samples.txt")
samps <- samps[,c("Comment.ENA_RUN.","Factor.Value.population.","Performer")]
colnames(samps) <- c("id","pop","perf")
stopifnot(all(samps$id == names(fitpar)))

# create a matrix of GC content percentile x samples
# which gives relative probabilities of observing
# fragments (scaled such that max = 1).
gc.knots <- seq(from=.4, to=.6, length=3)
gc.bk <- c(0,1)
frag_GC_bias <- matrix(nrow=101, ncol=30)
# check that first coef is intercept
stopifnot(names(fitpar[[1]]$coefs$all[1]) == "(Intercept)")
# check that coefs 2-5 are natural spline terms (ns)
stopifnot(all(grepl("^ns",names(fitpar[[1]]$coefs$all[2:5]))))

for (j in 1:30) {
  mm <- model.matrix(~ns(0:100/100,knots=gc.knots,Boundary.knots=gc.bk))
  coefs <- fitpar[[j]]$coefs$all[1:5]
  log.lambda <-  mm %*% coefs
  frag_GC_bias[,j] <- exp(log.lambda)
  frag_GC_bias[,j] <- frag_GC_bias[,j] / max(frag_GC_bias[,j])
}

# plot the fragment GC bias curves
## plot(0:100/100, frag_GC_bias[,1], type="n", ylim=c(0,1),
##      xlab="fragment GC", ylab="P(observe fragment)")
## for (j in 1:30) lines(0:100/100, frag_GC_bias[,j], col=rep(1:2, each=15)[j])

# roughly how much downsampling will occur?
0.01 * sum(frag_GC_bias[,1] * dnorm(0:100/100, mean(gc), sd(gc)))
0.01 * sum(frag_GC_bias[,16] * dnorm(0:100/100, mean(gc), sd(gc)))

save(sim_counts, fold_changes, frag_GC_bias, file="simulate.rda")
